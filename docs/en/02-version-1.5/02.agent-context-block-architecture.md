# Agent-Context-Block Architecture

This document provides a comprehensive explanation of the Agent-Context-Block architecture design pattern used in the agentsociety framework.

## Architecture Overview

The Agent-Context-Block architecture is a modular design pattern that enables flexible and extensible intelligent agent development. This architecture consists of three core components:

- **Agent**: Contains all the fundamental logic and functionality required for an intelligent agent's operation, serving as the core controller of the entire system.
- **Block**: Serves as a modular component that provides additional capabilities to agents (e.g., MobilityBlock enables agents to move within a city).
- **Context**: Acts as a data carrier that passes state information and execution results between Agent and Block, enabling decoupled communication between components.

### Component Integration Mechanism

The components in the architecture are integrated through the following mechanisms:

1. **Agent as Central Dispatcher**: The Agent holds multiple Block instances and manages Block registration and scheduling through BlockDispatcher.

2. **Context as Communication Bridge**: Both Agent and Block maintain their respective Context, implementing dot notation access and data passing through DotDict format.

3. **Unified Lifecycle Management**: All components follow a unified lifecycle pattern, ensuring consistency and predictability of data flow.

```python
# Component integration example
async def run(self) -> Any:
    # Agent controls the entire execution flow
    await self.before_forward()      # Agent preparation phase
    await self.before_blocks()       # Block preparation phase
    await self.forward()            # Agent core logic
    await self.after_blocks()       # Block cleanup phase
    await self.after_forward()      # Agent cleanup phase
```

## Agent

Agent is the core component of the system, responsible for the main decision-making logic of intelligent agents and coordination management of Blocks.

### Agent Definition and Design

When creating a custom Agent, you need to define the following key components as **class variables** that are directly bound to the corresponding agent:

#### 1. Agent Parameter Type Definition (ParamsType)

**Optional Component**: AgentParams defines configurable options for the corresponding agent, allowing you to adjust agent behavior through configuration rather than repeatedly modifying the agent source code. When you want to share your agent design and provide other users with parameters to adjust agent behavior, you can use AgentParams to achieve this goal.

```python
class AgentParams(BaseModel):
    """
    Agent parameters configuration
    """
    block_dispatch_prompt: str = Field(default=DISPATCHER_PROMPT, 
        description="The prompt used for the block dispatcher...")
    # Add custom parameters here
```

#### 2. Agent Context Type Definition (Context)

**Optional Component**: AgentContext serves two main purposes:
1. **Context Information Management**: Defines contextual information during agent execution, allowing access to key information in any scenario where the context object is accessible.
2. **Agent-Block Communication**: Can be passed to Blocks, enabling blocks to access information transmitted from the agent main body during runtime, while providing support for the separated design of Agent-Block architecture.

```python
class CustomAgentContext(AgentContext):
    """
    Custom agent context for specific agent type
    """
    current_task: str = ""
    emotional_state: str = "neutral"
    # Add agent-specific context fields
```

#### 3. Block Output Type Definition (BlockOutputType)

**Optional Component**: Defines the type of Block output that the current agent can receive, used for agent-block matching. This provides a separated design and compatibility solution for Agent-Block designers, ensuring type consistency across the architecture.

```python
class CustomBlockOutput(BlockOutput):
    """
    Standardized output format for all blocks used by this agent
    """
    action_taken: str
    success: bool
    # Define unified block output structure
```

#### 4. Status Attributes Configuration (StatusAttributes)

**Optional Component**: Used to define unique status entries for the current agent. The entries defined here serve two main purposes:
1. **Memory Integration**: All defined entries will be inserted into the agent's memory during initialization, accessible via `agent.memory.status.get('xx')` and updatable through the update method.
2. **Community Integration**: When shared to agentsociety-community, these status entries will be captured by the frontend to provide users with richer contextual information.

```python
from agentsociety.agent.memory_config_generator import StatusAttribute

class CustomAgent(Agent):
    StatusAttributes: list[StatusAttribute] = [
        StatusAttribute(name="health", type="int", default=100),
        StatusAttribute(name="location", type="dict", default={}),
        # Define agent's persistent state attributes
    ]
```

#### Complete Agent Class Example

Here's a comprehensive example showing how these class variables are defined and bound to an agent:

```python
from agentsociety.agent import Agent, AgentParams, AgentContext, BlockOutput
from agentsociety.agent.memory_config_generator import StatusAttribute
from pydantic import BaseModel, Field
from typing import Optional, Any

class CitizenAgentParams(AgentParams):
    """
    Configuration parameters for CitizenAgent
    """
    exploration_radius: float = Field(default=100.0, description="Maximum exploration radius")
    social_interaction_frequency: int = Field(default=5, description="Social interaction frequency per day")
    energy_consumption_rate: float = Field(default=1.0, description="Energy consumption multiplier")

class CitizenAgentContext(AgentContext):
    """
    Context information for CitizenAgent
    """
    current_goal: str = ""
    mood: str = "neutral"
    daily_schedule: list = Field(default_factory=list)
    visited_locations: list = Field(default_factory=list)

class CitizenBlockOutput(BlockOutput):
    """
    Standardized output format for CitizenAgent blocks
    """
    action_type: str
    success: bool
    energy_cost: float
    message: str = ""

class CitizenAgent(Agent):
    """
    Example CitizenAgent with all class variables defined
    """
    # Class variables directly bound to this agent type
    ParamsType = CitizenAgentParams
    Context = CitizenAgentContext
    BlockOutputType = CitizenBlockOutput
    StatusAttributes: list[StatusAttribute] = [
        StatusAttribute(name="health", type="int", default=100),
        StatusAttribute(name="energy", type="float", default=100.0),
        StatusAttribute(name="location", type="dict", default={"x": 0, "y": 0}),
        StatusAttribute(name="wealth", type="float", default=1000.0),
        StatusAttribute(name="social_connections", type="list", default=[]),
    ]
    description: str = "A citizen agent that can explore, interact socially, and manage daily activities"

    async def forward(self):
        """
        Main agent logic implementation
        """
        # Access agent's context
        current_goal = self.context.current_goal
        
        # Access agent's status from memory
        current_health = await self.memory.status.get("health")
        current_energy = await self.memory.status.get("energy")
        
        # Agent decision-making logic here
        if current_energy < 20:
            self.context.current_goal = "rest"
        elif not self.context.daily_schedule:
            self.context.current_goal = "plan_day"
        
        # Update status
        await self.memory.status.update("energy", current_energy - 1)
```

In this example, the `CitizenAgent` class demonstrates how all four class variables (`ParamsType`, `Context`, `BlockOutputType`, `StatusAttributes`) are directly bound to the agent class, providing a complete configuration framework for agent behavior, context management, block compatibility, and persistent state tracking.

### Agent Core Architecture

#### Initialization Process

```python
def __init__(
    self,
    id: int,
    name: str,
    type: AgentType,
    toolbox: AgentToolbox,
    memory: Memory,
    agent_params: Optional[Any] = None,
    blocks: Optional[list[Block]] = None,
) -> None:
    # Basic agent properties
    self._id = id
    self._name = name
    self._type = type
    
    # Core systems
    self._toolbox = toolbox
    self._memory = memory
    
    # Parameters and blocks management
    self.params = agent_params or self.default_params()
    
    # Block dispatcher for intelligent block selection
    self.dispatcher = BlockDispatcher(self.llm, self.memory)
    if blocks is not None:
        self.blocks = blocks
        self.dispatcher.register_blocks(self.blocks)
    
    # Context initialization
    context = self.default_context()
    self.context = context_to_dot_dict(context)
```

#### Block Dispatching Mechanism

Agent implements intelligent Block selection and execution through BlockDispatcher. **Every subclass that inherits from the Agent class automatically has a `self.dispatcher`** for specific block dispatch and usage.

**Key Features of BlockDispatcher:**

1. **Automatic Initialization**: The dispatcher is automatically created during agent initialization with LLM and memory references.

2. **Intelligent Block Selection**: Uses LLM-based decision making to select the most appropriate block based on context information.

3. **Function Schema Generation**: Automatically generates schemas describing available blocks for LLM function calling.

4. **Flexible Usage**: Agent designers determine how and when to use the dispatcher based on their specific design requirements.

```python
# BlockDispatcher registration and usage
self.dispatcher = BlockDispatcher(self.llm, self.memory)
if blocks is not None:
    for block in blocks:
        # Validate Block output type compatibility
        if block.OutputType != self.BlockOutputType:
            raise ValueError(f"Block output type mismatch")
        # Automatically set agent reference if Block needs it
        if block.NeedAgent:
            block.set_agent(self)
    self.blocks = blocks
    self.dispatcher.register_blocks(self.blocks)
```

**How BlockDispatcher Works:**

1. **Block Registration**: Blocks are registered with their class names as identifiers
2. **Context-Based Selection**: **By default, the dispatcher uses `context.current_intention` to make decisions**, but designers can customize this behavior by adjusting the dispatcher prompt through `dispatcher.register_dispatcher_prompt()`
3. **LLM Function Calling**: Generates function schemas and uses LLM to select appropriate blocks
4. **Fallback Handling**: Returns `None` if no suitable block is found

```python
# Example dispatcher usage in agent forward method
async def forward(self):
    # Set current intention in context (default behavior)
    self.context.current_intention = await self.determine_intention()
    
    # Use dispatcher to select appropriate block
    selected_block = await self.dispatcher.dispatch(self.context)
    
    if selected_block:
        # Execute the selected block with agent context
        block_output = await selected_block.forward(self.context)
        # Process block output
        await self.process_block_output(block_output)
    else:
        # Handle case when no suitable block is found
        await self.handle_no_block_available()
```

**Important Design Considerations:**

- **Agent Designer Responsibility**: The agent designer determines how and when to use the dispatcher. This includes:
  - When to call `dispatcher.dispatch()`
  - How to process the selected block's output
  - How to handle cases when no suitable block is found
  - **How to set up the context information for optimal block selection** (can be customized beyond the default `current_intention`)

- **Customizable Selection Logic**: While the default dispatcher prompt uses `context.current_intention`, designers can modify this behavior by registering custom dispatcher prompts that utilize different context fields or combinations of context information.

- **Documentation Requirements**: If you plan to share your agent design publicly, you should provide clear documentation explaining:
  - When and how the dispatcher is used in your agent's logic
  - What context information is required for proper block selection
  - How blocks are expected to be used within your agent's workflow
  - Any specific patterns or conventions other users should follow
  - **What context fields your custom dispatcher prompt uses (if different from the default)**

**Example of Dispatcher Configuration:**

```python
class CitizenAgent(Agent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Dispatcher is automatically available as self.dispatcher
        
        # Customize dispatcher prompt to use different context fields
        custom_prompt = """
        Based on the citizen's current goal and situation, select the most appropriate action block.
        Consider the citizen's energy level, time of day, and social needs.
        
        Current situation:
        Goal: ${context.current_goal}
        Energy: ${context.energy_level}
        Time: ${context.current_time}
        Mood: ${context.mood}
        """
        # Register custom prompt that uses multiple context fields instead of just current_intention
        self.dispatcher.register_dispatcher_prompt(custom_prompt)
    
    async def forward(self):
        # Update context with information needed by custom dispatcher prompt
        self.context.current_goal = await self.determine_goal()
        self.context.energy_level = await self.memory.status.get("energy")
        self.context.current_time = self.environment.get_datetime()
        self.context.mood = await self.assess_mood()
        
        # Note: No need to set current_intention since we're using custom prompt
        # Use dispatcher to select and execute appropriate block
        selected_block = await self.dispatcher.dispatch(self.context)
        if selected_block:
            result = await selected_block.forward(self.context)
            await self.update_context_from_result(result)
```

This flexible dispatcher system allows for sophisticated agent behaviors while maintaining modularity and extensibility. The key is to document your dispatcher usage patterns clearly so other users can understand and effectively use your agent design.

### Agent Execution Lifecycle

Agent follows a strict execution lifecycle, ensuring all components execute in the correct order:

```python
async def run(self) -> Any:
    start_time = time.time()
    
    # Phase 1: Preparation
    await self.before_forward()     # Agent's own preparation work
    await self.before_blocks()      # All blocks' preparation work
    
    # Phase 2: Core Execution
    await self.forward()           # Agent's core decision logic
    
    # Phase 3: Cleanup
    await self.after_blocks()      # All blocks' cleanup work
    await self.after_forward()     # Agent's own cleanup work
    
    end_time = time.time()
    return end_time - start_time
```

#### Specific Functions of Each Phase

```python
async def before_blocks(self):
    """Execute before_forward for all registered blocks"""
    if self.blocks is None:
        return
    for block in self.blocks:
        await block.before_forward()

async def after_blocks(self):
    """Execute after_forward for all registered blocks"""
    if self.blocks is None:
        return
    for block in self.blocks:
        await block.after_forward()
```

## Block

Block is a modular functional component that provides specific capability extensions to Agents, implementing a plugin-based architecture design.

### Block Definition and Design

When creating a custom Block, you need to define the following key components as **class variables** that are directly bound to the corresponding block:

#### 1. Block Parameter Type Definition (ParamsType)

**Optional Component**: BlockParams defines configurable options for the corresponding block, allowing you to adjust block behavior through configuration rather than repeatedly modifying the block source code. When you want to share your block design and provide other users with parameters to adjust block behavior, you can use BlockParams to achieve this goal.

```python
class BlockParams(BaseModel):
    """
    Block parameters configuration
    """
    block_memory: Optional[dict[str, Any]] = None
    # Add custom parameters here
```

#### 2. Block Context Type Definition (Context)

**Optional Component**: BlockContext serves two main purposes:
1. **Context Information Management**: Defines contextual information during block execution, allowing access to key block-specific information in any scenario where the context object is accessible.
2. **Block State Management**: Manages block's internal state and execution history, providing a structured way to track block operations and results.

```python
class CustomBlockContext(BlockContext):
    """
    Custom block context for specific block type
    """
    execution_state: str = "idle"
    last_action_result: dict = Field(default_factory=dict)
    resource_usage: dict = Field(default_factory=dict)
    # Add block-specific context fields
```

#### 3. Block Output Type Definition (OutputType)

**Optional Component**: Defines the standardized output format that the block produces, used for block-agent compatibility and type consistency. This ensures that agents can properly process and understand the results returned by the block.

```python
class CustomBlockOutput(BlockOutput):
    """
    Standardized output format for this block type
    """
    action_performed: str
    success: bool
    data_produced: dict = Field(default_factory=dict)
    # Define structured output for this block type
```

#### 4. Block Metadata Definition

**Optional Components**: These class variables define the block's identity and capabilities:

- **name**: A string identifier for the block
- **description**: A detailed explanation of the block's purpose and functionality
- **actions**: A dictionary mapping action names to their descriptions, defining what capabilities the block exposes
- **NeedAgent**: A boolean indicating whether the block requires access to the agent instance

```python
class CustomBlock(Block):
    name: str = "CustomBlock"
    description: str = "Provides custom functionality for agents"
    actions: dict[str, str] = {
        "perform_action": "Performs a specific custom action",
        "get_status": "Returns the current status of the block"
    }
    NeedAgent: bool = True  # This block requires agent reference
```

#### Complete Block Class Example

Here's a comprehensive example showing how these class variables are defined and bound to a block:

```python
from agentsociety.agent.block import Block, BlockParams, BlockContext, BlockOutput
from pydantic import BaseModel, Field
from typing import Optional, Any

class MobilityBlockParams(BlockParams):
    """
    Configuration parameters for MobilityBlock
    """
    max_speed: float = Field(default=5.0, description="Maximum movement speed")
    energy_cost_per_move: float = Field(default=1.0, description="Energy cost per movement")
    navigation_accuracy: float = Field(default=0.95, description="Navigation accuracy (0-1)")

class MobilityBlockContext(BlockContext):
    """
    Context information for MobilityBlock
    """
    current_position: dict = Field(default_factory=dict)
    movement_history: list = Field(default_factory=list)
    planned_route: list = Field(default_factory=list)
    last_movement_time: str = ""
    energy_consumed: float = 0.0

class MobilityBlockOutput(BlockOutput):
    """
    Standardized output for mobility operations
    """
    action_type: str
    new_position: dict
    distance_traveled: float
    energy_consumed: float
    success: bool
    message: str = ""

class MobilityBlock(Block):
    """
    Example MobilityBlock with all class variables defined
    """
    # Class variables directly bound to this block type
    ParamsType = MobilityBlockParams
    Context = MobilityBlockContext
    OutputType = MobilityBlockOutput
    
    # Block metadata
    name: str = "MobilityBlock"
    description: str = "Provides movement and location management capabilities for agents"
    actions: dict[str, str] = {
        "move_to_location": "Move the agent to a specified location",
        "get_current_location": "Get the agent's current location",
        "plan_route": "Plan an optimal route to destination",
        "check_accessibility": "Check if a location is accessible"
    }
    NeedAgent: bool = True  # This block requires agent reference

    async def forward(self, agent_context: DotDict):
        """
        Main block logic implementation
        """
        # Access block's own context
        current_pos = self.context.current_position
        
        # Access agent's context (safely copied)
        agent_goal = agent_context.current_goal
        
        # Perform mobility-related operations
        if agent_goal == "explore":
            new_position = await self.explore_nearby_area()
            distance = self.calculate_distance(current_pos, new_position)
            energy_cost = distance * self.params.energy_cost_per_move
            
            # Update block context
            self.context.current_position = new_position
            self.context.movement_history.append({
                "from": current_pos,
                "to": new_position,
                "timestamp": agent_context.current_time
            })
            
            return MobilityBlockOutput(
                action_type="exploration",
                new_position=new_position,
                distance_traveled=distance,
                energy_consumed=energy_cost,
                success=True,
                message=f"Successfully explored to {new_position}"
            )
```

### Block Core Architecture

#### Initialization Process

```python
def __init__(
    self,
    llm: Optional[LLM] = None,
    environment: Optional[Environment] = None,
    agent_memory: Optional[Memory] = None,
    block_params: Optional[Any] = None,
):
    # Core dependencies
    self._llm = llm
    self._agent_memory = agent_memory
    self._environment = environment
    self._agent = None
    
    # Parameters processing
    if block_params is None:
        block_params = self.default_params()
    self.params = block_params
    
    # Block memory initialization from parameters
    for key, value in block_params.model_dump().items():
        if key == "block_memory":
            self._block_memory = StateMemory(value)
        else:
            setattr(self, key, value)
    
    # Context initialization
    context = self.default_context()
    self.context = context_to_dot_dict(context)
```

#### Agent Association Mechanism

Blocks that require agent access (when `NeedAgent = True`) are automatically associated with their parent agent:

```python
def set_agent(self, agent: Any):
    """
    Set the associated agent for blocks that need agent reference
    """
    self._agent = agent

@property
def agent(self) -> Any:
    """
    Access the associated agent instance
    """
    if self._agent is None:
        raise RuntimeError("Agent access before assignment, please `set_agent` first!")
    return self._agent

# In Agent initialization, automatic agent setting for blocks that need it
for block in blocks:
    if block.NeedAgent:
        block.set_agent(self)
```

### Block Execution Lifecycle

Block follows a standardized three-phase lifecycle pattern that integrates with the Agent's execution flow:

```python
async def before_forward(self):
    """
    Preparation phase - setup context and validate prerequisites
    """
    # Initialize block-specific resources
    # Validate dependencies and prerequisites
    # Prepare context data for execution
    # Example: Check if required external services are available
    pass

@auto_deepcopy_dotdict
async def forward(self, agent_context: DotDict):
    """
    Core execution phase - implement main block functionality
    
    Args:
        agent_context (DotDict): Agent's context passed to the block (automatically deep-copied)
    
    Returns:
        Block-specific output conforming to OutputType
    """
    # This method must be implemented by subclasses
    # Contains the main logic of what the block does
    # Safely processes agent context without affecting original
    raise NotImplementedError("Subclasses should implement this method")

async def after_forward(self):
    """
    Cleanup phase - update context and manage state
    """
    # Update block context with execution results
    # Perform cleanup operations
    # Save state to block memory if needed
    # Example: Release acquired resources
    pass
```

**Lifecycle Integration with Agent:**

```python
# In Agent's run() method, blocks are called in sequence:
async def before_blocks(self):
    """Execute before_forward for all registered blocks"""
    for block in self.blocks:
        await block.before_forward()

# Agent's main forward() method executes here

async def after_blocks(self):
    """Execute after_forward for all registered blocks"""
    for block in self.blocks:
        await block.after_forward()
```

### Block Communication and Integration

#### Agent-Block Context Passing Mechanism

**A critical aspect of the Agent-Block architecture is that when an Agent calls a Block, it passes the Agent's context to the Block.** This enables blocks to access agent-level information and make informed decisions based on the agent's current state.

**How Context Passing Works:**

1. **Agent Preparation**: The agent updates its context with current information
2. **Context Transmission**: The agent passes its context to the block's `forward()` method
3. **Safe Processing**: The block receives a deep copy of the agent context (via `@auto_deepcopy_dotdict`)
4. **Block Execution**: The block uses both agent context and its own context to perform operations
5. **Result Return**: The block returns structured output to the agent

```python
# Example of Agent calling Block with context passing
class CitizenAgent(Agent):
    async def forward(self):
        # Agent updates its own context with current information
        self.context.current_goal = await self.determine_goal()
        self.context.energy_level = await self.memory.status.get("energy")
        self.context.current_time = self.environment.get_datetime()
        self.context.emotional_state = "curious"
        
        # Agent calls block and passes its context
        for block in self.blocks:
            # The agent's context is automatically passed to block.forward()
            block_output = await block.forward(self.context)
            
            # Process the block's output
            if block_output.success:
                await self.handle_successful_block_result(block_output)
            else:
                await self.handle_failed_block_result(block_output)

class MobilityBlock(Block):
    @auto_deepcopy_dotdict
    async def forward(self, agent_context: DotDict):
        """
        Block receives agent context and can access agent's information
        """
        # Access agent's context information
        agent_goal = agent_context.current_goal          # Access agent's goal
        agent_energy = agent_context.energy_level        # Access agent's energy
        agent_time = agent_context.current_time          # Access current time
        agent_mood = agent_context.emotional_state       # Access agent's mood
        
        # Combine agent context with block's own context for decision making
        current_position = self.context.current_position
        movement_history = self.context.movement_history
        
        # Make informed decisions based on both agent and block context
        if agent_goal == "explore" and agent_energy > 30:
            # Use agent's information to guide block behavior
            exploration_radius = min(agent_energy * 2, self.params.max_speed)
            new_position = await self.explore_with_radius(current_position, exploration_radius)
            
            # Update block's own context
            self.context.current_position = new_position
            self.context.last_movement_time = agent_time
            
            # Safe to modify agent_context (it's a deep copy)
            agent_context.last_exploration_result = "successful"
            
            return MobilityBlockOutput(
                action_type="exploration",
                new_position=new_position,
                distance_traveled=self.calculate_distance(current_position, new_position),
                energy_consumed=exploration_radius * 0.5,
                success=True,
                message=f"Explored to {new_position} based on agent goal: {agent_goal}"
            )
```

#### Context-Safe Communication

Blocks receive agent context through the `@auto_deepcopy_dotdict` decorator, ensuring safe data access:

```python
@auto_deepcopy_dotdict
async def forward(self, agent_context: DotDict):
    """
    Safe context processing - modifications don't affect original agent context
    """
    # Safe to modify agent_context here - it's a deep copy
    agent_context.block_processing_data = "some_value"
    agent_context.block_annotations = ["processed", "analyzed"]
    
    # Access agent information for decision making
    agent_goal = agent_context.current_goal
    agent_status = agent_context.current_status
    
    # Use agent context to influence block behavior
    if agent_goal == "rest":
        # Adjust block behavior based on agent's intention
        action_intensity = "low"
    elif agent_goal == "work":
        action_intensity = "high"
    
    # Update own context based on agent information
    self.context.last_processed_goal = agent_goal
    self.context.action_intensity = action_intensity
    
    return self.OutputType(
        action_performed=f"executed_{action_intensity}_intensity_action",
        success=True,
        data_produced={"agent_goal": agent_goal, "intensity": action_intensity}
    )
```

**Benefits of Context Passing:**

1. **Informed Decision Making**: Blocks can make smarter decisions based on agent's current state and goals
2. **Dynamic Behavior**: Block behavior can adapt based on agent context rather than being static
3. **Coordination**: Multiple blocks can work together through shared agent context
4. **Data Safety**: Deep copy mechanism ensures agent's original context remains unchanged
5. **Flexibility**: Agents can provide different context information to different blocks as needed

**Example of Multi-Block Coordination through Agent Context:**

```python
class CitizenAgent(Agent):
    async def forward(self):
        # Set up rich context for blocks to use
        self.context.current_goal = "daily_routine"
        self.context.time_of_day = "morning"
        self.context.energy_level = await self.memory.status.get("energy")
        self.context.social_needs = await self.assess_social_needs()
        self.context.work_schedule = await self.get_work_schedule()
        
        # Call multiple blocks with the same rich context
        mobility_result = await self.mobility_block.forward(self.context)
        social_result = await self.social_block.forward(self.context)
        work_result = await self.work_block.forward(self.context)
        
        # Each block can make informed decisions based on the full agent context
        # while maintaining their specialized functionality

# MobilityBlock uses agent context to decide movement patterns
# SocialBlock uses agent context to determine interaction priorities  
# WorkBlock uses agent context to plan work activities
# All blocks coordinate through shared access to agent's state and goals
```

This context passing mechanism is fundamental to the Agent-Context-Block architecture, enabling sophisticated coordination between agents and their specialized capability blocks while maintaining clean separation of concerns and data safety.

## Context

The Context system is the data carrier in the Agent-Context-Block architecture, responsible for passing state information and execution results between different components, enabling decoupled communication between components.

### Context Design Philosophy

The Context system is based on the following design principles:

1. **Type Safety**: Using Pydantic models to ensure type safety of data structures
2. **Flexible Access**: Implementing dot notation access syntax through DotDict for improved code readability
3. **Data Isolation**: Ensuring data isolation between components through deep copy mechanisms
4. **Extensibility**: Supporting nested structures and dynamic merge operations

### Context Core Components

#### 1. AgentContext - Agent Context

```python
class AgentContext(BaseModel):
    """
    Base context class for agents
    Define agent-specific context fields
    """
    # Example fields:
    # current_goal: str = ""
    # emotional_state: str = "neutral"
    # decision_history: list = Field(default_factory=list)
    pass
```

#### 2. BlockContext - Block Context

```python
class BlockContext(BaseModel):
    """
    Base context class for blocks
    Define block-specific context fields
    """
    # Example fields:
    # execution_state: str = "idle"
    # last_action_result: dict = Field(default_factory=dict)
    # resource_usage: dict = Field(default_factory=dict)
    pass
```

#### 3. DotDict - Dot Notation Dictionary

DotDict is the core data structure of the Context system, providing the following functionality:

```python
class DotDict(dict):
    """
    Enhanced dictionary with dot notation access and merge capabilities
    """
    
    def __getattr__(self, key):
        """Enable dot notation access: dict.key"""
        return self.get(key)
    
    def __setattr__(self, key, value):
        """Enable dot notation assignment: dict.key = value"""
        self[key] = value
    
    def __init__(self, *args, **kwargs):
        super(DotDict, self).__init__(*args, **kwargs)
        # Recursively convert nested dictionaries to DotDict
        for key, value in self.items():
            if isinstance(value, dict):
                self[key] = DotDict(value)
            elif isinstance(value, list):
                self[key] = [
                    DotDict(item) if isinstance(item, dict) else item 
                    for item in value
                ]
```

### Context Conversion Mechanism

#### Pydantic to DotDict Conversion

```python
def context_to_dot_dict(context: Union[AgentContext, BlockContext]) -> DotDict:
    """
    Convert Pydantic context models to DotDict for enhanced access
    
    Args:
        context: AgentContext or BlockContext instance
    
    Returns:
        DotDict with dot notation access capabilities
    """
    # Extract data using Pydantic's model_dump() method
    context_dict = context.model_dump()
    # Convert to DotDict for enhanced access
    return DotDict(context_dict)
```

#### Usage Example

```python
# In Agent initialization
context = self.default_context()  # Returns AgentContext instance
self.context = context_to_dot_dict(context)  # Convert to DotDict

# Dot notation access
self.context.current_goal = "explore_city"
self.context.emotional_state = "curious"
self.context.decision_history.append("decided_to_move")
```

### Context Merge Mechanism

DotDict supports intelligent merge operations, facilitating combination of context data from different sources:

```python
def merge(self, other):
    """
    Intelligent merge with another DotDict
    
    Args:
        other (DotDict): The DotDict to merge with
    
    Returns:
        self (DotDict): The merged DotDict with updated values
    """
    if not isinstance(other, DotDict):
        other = DotDict(other)
    
    for key, value in other.items():
        if (key in self 
            and isinstance(self[key], DotDict) 
            and isinstance(value, DotDict)):
            # Recursively merge nested DotDict objects
            self[key].merge(value)
        else:
            # Direct assignment for non-DotDict values
            self[key] = value
    return self

# Operator overloading for convenient merging
agent_context = DotDict({"goal": "explore", "energy": 100})
block_context = DotDict({"position": {"x": 10, "y": 20}})

# Method 1: Using merge method
combined_context = agent_context.merge(block_context)

# Method 2: Using | operator
combined_context = agent_context | block_context

# Method 3: Using |= operator for in-place merge
agent_context |= block_context
```

### Context Data Protection Mechanism

#### Deep Copy Decorator

To ensure safe passing of Context data between different components, the system provides an automatic deep copy decorator:

```python
@auto_deepcopy_dotdict
async def forward(self, agent_context: DotDict):
    """
    Block forward method with automatic deep copy protection
    
    The decorator ensures that any modifications to agent_context
    within this method do not affect the original context
    """
    # Safe to modify agent_context here
    agent_context.block_specific_data = "some_value"
    # Original context remains unchanged
    pass
```

#### Decorator Implementation Principle

```python
def auto_deepcopy_dotdict(func):
    """
    Decorator that automatically deep copies DotDict arguments
    """
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Deep copy DotDict positional arguments
        new_args = []
        for arg in args:
            if isinstance(arg, DotDict):
                new_args.append(copy.deepcopy(arg))
            else:
                new_args.append(arg)
        
        # Deep copy DotDict keyword arguments
        new_kwargs = {}
        for key, value in kwargs.items():
            if isinstance(value, DotDict):
                new_kwargs[key] = copy.deepcopy(value)
            else:
                new_kwargs[key] = value
        
        return func(*new_args, **new_kwargs)
    return wrapper
```

### Context Application Example in Architecture

#### Complete Agent-Block-Context Interaction Flow

```python
class CitizenAgent(Agent):
    """Example agent implementation showing context usage"""
    
    async def forward(self):
        # Agent updates its context
        self.context.current_time = self.environment.get_datetime()
        self.context.current_goal = await self.decide_goal()
        
        # Pass context to blocks for execution
        for block in self.blocks:
            # Context is automatically deep-copied by decorator
            block_output = await block.forward(self.context)
            
            # Agent processes block output and updates context
            self.context.last_block_outputs[block.name] = block_output

class MobilityBlock(Block):
    """Example block implementation showing context usage"""
    
    @auto_deepcopy_dotdict
    async def forward(self, agent_context: DotDict):
        # Block can safely read and modify agent context
        current_goal = agent_context.current_goal
        
        # Update block's own context
        self.context.last_movement_time = agent_context.current_time
        
        # Perform block-specific operations
        if current_goal == "explore_city":
            new_position = await self.explore_nearby_area()
            
            # Update context with results (affects copy, not original)
            agent_context.exploration_progress = "in_progress"
            
        return MobilityBlockOutput(
            new_position=new_position,
            distance_traveled=self.calculate_distance(),
            energy_consumed=self.calculate_energy_cost()
        )
```

This Context design achieves loosely coupled communication between Agent and Block, ensuring data safety while providing a flexible data sharing mechanism, making it a key component of the entire Agent-Context-Block architecture.

## Summary

The Agent-Context-Block architecture represents a sophisticated, modular approach to building intelligent agent systems that prioritizes flexibility, extensibility, and maintainability. This architecture enables developers to create complex agent behaviors through the composition of simpler, reusable components.

### Core Architecture Principles

1. **Modularity**: The separation of concerns between Agent (decision-making), Block (capability provision), and Context (data communication) enables clean, maintainable code architectures.

2. **Extensibility**: New capabilities can be added through custom Blocks without modifying existing Agent code, supporting rapid feature development and experimentation.

3. **Type Safety**: Strong typing through Pydantic models and standardized output formats ensures reliable component interaction and reduces runtime errors.

4. **Data Safety**: The deep copy mechanism in context passing prevents unintended side effects while enabling rich data sharing between components.

### Key Components Integration

- **Agent** serves as the central orchestrator, managing the overall decision-making process and coordinating Block execution through intelligent dispatching.

- **Block** provides specialized capabilities as modular plugins, each with well-defined interfaces and configurable parameters.

- **Context** acts as the communication bridge, enabling safe data sharing while maintaining component isolation through the DotDict system.

### Major Benefits

**For Developers:**
- **Rapid Development**: Reusable blocks accelerate feature implementation
- **Clear Separation**: Well-defined interfaces simplify debugging and maintenance
- **Flexible Configuration**: Parameter-based customization without code changes
- **Testability**: Isolated components enable comprehensive unit testing

**For Agent Designers:**
- **Intelligent Dispatching**: LLM-based block selection enables sophisticated decision-making
- **Rich Context Sharing**: Comprehensive information flow between components
- **Lifecycle Management**: Structured execution phases ensure predictable behavior
- **Community Integration**: Standardized patterns facilitate sharing and collaboration

**For System Architecture:**
- **Scalability**: Modular design supports complex multi-agent scenarios
- **Maintainability**: Clear component boundaries reduce technical debt
- **Reusability**: Block libraries can be shared across different agent types
- **Evolution**: Architecture supports incremental enhancement and refactoring

### Best Practices

#### Agent Development
1. **Document Dispatcher Usage**: Clearly explain how and when your agent uses the dispatcher
2. **Define Rich Context**: Provide comprehensive context information for optimal block selection
3. **Handle Block Failures**: Implement robust error handling for block execution failures
4. **Use Status Attributes**: Leverage persistent state tracking for complex agent behaviors

#### Block Development
1. **Clear Interface Definition**: Define precise input/output contracts through typed parameters
2. **Conditional Execution**: Use decorators to implement intelligent triggering logic
3. **Context Safety**: Always use the `@auto_deepcopy_dotdict` decorator for context handling
4. **Resource Management**: Implement proper cleanup in `after_forward()` methods

#### Context Design
1. **Structured Information**: Use well-defined Pydantic models for type safety
2. **Meaningful Names**: Choose descriptive field names that clearly indicate purpose
3. **Appropriate Granularity**: Balance between too much and too little context information
4. **Version Compatibility**: Consider backward compatibility when evolving context structures

### Common Use Cases

- **Multi-Modal Agents**: Agents with mobility, social interaction, and task execution capabilities
- **Simulation Systems**: Complex agent-based simulations with specialized behavior modules
- **AI Assistants**: Intelligent assistants with pluggable skill modules
- **Robotic Systems**: Autonomous systems with interchangeable capability components
- **Game AI**: NPCs with modular behavior systems for different game mechanics

### Getting Started Recommendations

1. **Start Simple**: Begin with basic Agent and Block implementations before adding complexity
2. **Follow Examples**: Use the provided `CitizenAgent` and `MobilityBlock` examples as templates
3. **Iterative Development**: Gradually add blocks and refine context sharing patterns
4. **Test Thoroughly**: Verify component interactions through comprehensive testing
5. **Document Everything**: Maintain clear documentation for custom implementations

### Architecture Evolution

The Agent-Context-Block architecture is designed to evolve with changing requirements:

- **New Block Types**: Additional capability blocks can be developed and integrated seamlessly
- **Enhanced Dispatchers**: More sophisticated dispatching logic can be implemented without affecting existing components
- **Extended Context Systems**: Context structures can be enhanced while maintaining backward compatibility
- **Performance Optimizations**: Individual components can be optimized independently

This architecture provides a solid foundation for building sophisticated agent systems that can grow and adapt to complex requirements while maintaining code quality and developer productivity. Whether you're building simple simulation agents or complex AI systems, the Agent-Context-Block pattern offers the flexibility and structure needed for successful implementation.


